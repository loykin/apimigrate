package main

import (
	"strings"

	"github.com/loykin/apirun"
	"github.com/loykin/apirun/internal/constants"
	"github.com/loykin/apirun/internal/store/postgresql"
	"github.com/loykin/apirun/internal/util"
)

// StoreFactory handles the creation of store configurations
type StoreFactory struct{}

// NewStoreFactory creates a new store factory
func NewStoreFactory() *StoreFactory {
	return &StoreFactory{}
}

// CreateStoreConfig creates a store configuration from the given config
func (f *StoreFactory) CreateStoreConfig(config StoreConfig) *apirun.StoreConfig {
	if config.Disabled {
		return nil
	}

	stType := util.TrimAndLower(config.Type)
	if stType == "" {
		return nil
	}

	// Build table names
	tableNames := buildTableNames(
		config.TablePrefix,
		config.TableSchemaMigrations,
		config.TableMigrationRuns,
		config.TableStoredEnv,
	)

	// Use appropriate database-specific builder
	if stType == apirun.DriverPostgresql {
		return buildPostgresStoreConfig(config.Postgres, tableNames)
	}

	// Default to SQLite
	return buildSqliteStoreConfig(config.SQLite.Path, tableNames)
}

// buildTableNames constructs the table names based on the configuration
func buildTableNames(prefix, schemaMigrations, migrationRuns, storedEnv string) apirun.TableNames {
	// Trim all table-related strings at once
	fields := util.TrimSpaceFields(prefix, schemaMigrations, migrationRuns, storedEnv)
	prefix, sm, mr, se := fields[0], fields[1], fields[2], fields[3]

	// Apply prefix defaults if prefix is provided but specific names are empty
	if prefix != "" {
		if sm == "" {
			sm = prefix + constants.SchemaMigrationsSuffix
		}
		if mr == "" {
			mr = prefix + constants.MigrationLogSuffix
		}
		if se == "" {
			se = prefix + constants.StoredEnvSuffix
		}
	}

	return apirun.TableNames{
		SchemaMigrations: sm,
		MigrationRuns:    mr,
		StoredEnv:        se,
	}
}

// buildPostgresStoreConfig creates a configured PostgreSQL store config
func buildPostgresStoreConfig(config postgresql.Config, tableNames apirun.TableNames) *apirun.StoreConfig {
	// Generate DSN using postgresql.Config's ToMap() method
	pgConfig := config
	configMap := pgConfig.ToMap()

	// Use the DSN generated by ToMap()
	if dsn, ok := configMap["dsn"].(string); ok {
		pgConfig.DSN = dsn
	}

	// Convert to apirun type and create store config
	pg := apirun.PostgresConfig(pgConfig)
	return apirun.NewPostgresStoreConfig(&pg, tableNames)
}

// buildSqliteStoreConfig creates a configured SQLite store config
func buildSqliteStoreConfig(path string, tableNames apirun.TableNames) *apirun.StoreConfig {
	sqlite := &apirun.SqliteConfig{Path: strings.TrimSpace(path)}
	return apirun.NewSqliteStoreConfig(sqlite, tableNames)
}
